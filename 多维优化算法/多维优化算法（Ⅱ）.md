# Python实现多维优化算法（Ⅱ）

---

## 牛顿法

牛顿法的难点在于每次迭代时下降方向的求解。迭代公式为：$$x^{(k+1)}=x^{(k)}-F(x^{(k)})^{-1}g^{(k)}$$由于求逆矩阵用编程实现较为困难，故将上述公式进行变形得到：$$d^{(k)}=-F(x^{(k)})^{-1}g^{(k)}$$ $$F(x^{(k)})d^{(k)}=-g^{(k)}$$这时，我们仅需利用高斯消元法解上述线性方程组得到$d^{(k)}$即可，则迭代公式变为：$$x^{(k+1)}=x^{(k)}+d^{(k)}$$不妨以函数$f(x_1,x_2,x_3)=\frac{3}{2}x_1^2+2x_2^2+\frac{3}{2}x_3^2+x_1x_3-3x_1-x_3$为例实现牛顿法。
这里需要说明的有：
1. 我们这里选择的函数为二次型函数，如果选择非二次型函数，有可能会遇到黑塞矩阵不可逆、黑塞矩阵不正定等问题。
2. 由于我们这里选择了二次型函数，因此我们只需一步迭代即可达到极值点（事实也是如此）。

**实现代码如下：**

~~~Python
def Gaussian_Elimination(g,H):
    """
    此函数为实现高斯消元的函数
    此函数的问题有：
    1、只能处理有唯一解的情况
    2、消元过程中不能变换行的位置，因此可能出现除以0的错误
    但此函数足够应付本次处理的函数f
    """

    for i in range(2,0,-1):
        n=i
        while n>0:
            temp=float(H[3-n][2-i]/H[2-i][2-i])
            for j in range(0,3):
                H[3-n][j]=H[3-n][j]-temp*H[2-i][j]
            g[3-n]=g[3-n]-temp*g[2-i]
            n=n-1

    for i in range(2,0,-1):
        n=i-1
        while n>=0:
            temp=float(H[n][i]/H[i][i])
            H[n][i]=H[n][i]-temp*H[i][i]
            g[n]=g[n]-temp*g[i]
            n=n-1

    for i in range(0,3):
        g[i]=g[i]/H[i][i]

    return g


def Solve_Grid(x):
    """此函数负责求解梯度"""
    g=[float(3*x[0]+x[2]-3),4*x[1]+2*x[2],x[0]+2*x[1]+3*x[2]-1]
    return g

def Solve_H(x):
    """此函数负责求解黑塞矩阵"""
    H=[[3.0,0,1],[0,4,2],[1,2,3]]
    return H

if __name__=='__main__':

    x=[0.0,0,0]

    # 对于二次型函数牛顿法可以一次迭代达到极值点
    for i in range(0,1):
        d=Gaussian_Elimination(Solve_Grid(x),Solve_H(x))
        for j in range(0,3):
            x[j]=x[j]-d[j]
        print(f"第{i+1}次迭代时，得到的解为{x}")
~~~

**实验结果分析：**

~~~
第1次迭代时，得到的解为[1.0, 0.0, 0.0]
~~~

显然，运行结果符合预期，一次即达到了极值点。